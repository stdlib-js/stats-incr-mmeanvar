{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2018 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport { isPrimitive as isPositiveInteger } from '@stdlib/assert-is-positive-integer';\nimport isArrayLike from '@stdlib/assert-is-array-like-object';\nimport isnan from '@stdlib/math-base-assert-is-nan';\nimport Float64Array from '@stdlib/array-float64';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Returns an accumulator function which incrementally computes a moving arithmetic mean and unbiased sample variance.\n*\n* ## Method\n*\n* -   Let \\\\(W\\\\) be a window of \\\\(N\\\\) elements over which we want to compute an unbiased sample variance.\n*\n* -   The difference between the unbiased sample variance in a window \\\\(W_i\\\\) and the unbiased sample variance in a window \\\\(W_{i+1})\\\\) is given by\n*\n*     ```tex\n*     \\Delta s^2 = s_{i+1}^2 - s_{i}^2\n*     ```\n*\n* -   If we multiply both sides by \\\\(N-1\\\\),\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = (N-1)s_{i+1}^2 - (N-1)s_{i}^2\n*     ```\n*\n* -   If we substitute the definition of the unbiased sample variance having the form\n*\n*     ```tex\n*     \\begin{align*}\n*     s^2 &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i - \\bar{x})^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} (x_i^2 - 2\\bar{x}x_i + \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2\\bar{x} \\sum_{i=1}^{N} x_i + \\sum_{i=1}^{N} \\bar{x}^2) \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - \\frac{2N\\bar{x}\\sum_{i=1}^{N} x_i}{N} + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - 2N\\bar{x}^2 + N\\bar{x}^2 \\biggr) \\\\\n*         &= \\frac{1}{N-1} \\biggl( \\sum_{i=1}^{N} x_i^2 - N\\bar{x}^2 \\biggr)\n*     \\end{align*}\n*     ```\n*\n*     we return\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = \\biggl(\\sum_{k=1}^N x_k^2 - N\\bar{x}_{i+1}^2 \\biggr) - \\biggl(\\sum_{k=0}^{N-1} x_k^2 - N\\bar{x}_{i}^2 \\biggr)\n*     ```\n*\n* -   This can be further simplified by recognizing that subtracting the sums reduces to \\\\(x_N^2 - x_0^2\\\\); in which case,\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= x_N^2 - x_0^2 - N\\bar{x}_{i+1}^2 + N\\bar{x}_{i}^2 \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1}^2 - \\bar{x}_{i}^2) \\\\\n*     &= x_N^2 - x_0^2 - N(\\bar{x}_{i+1} - \\bar{x}_{i})(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* -   Recognizing that the difference of means can be expressed\n*\n*     ```tex\n*     \\bar{x}_{i+1} - \\bar{x}_i = \\frac{1}{N} \\biggl( \\sum_{k=1}^N x_k - \\sum_{k=0}^{N-1} x_k \\biggr) = \\frac{x_N - x_0}{N}\n*     ```\n*\n*     and substituting into the equation above\n*\n*     ```tex\n*     (N-1)(\\Delta s^2) = x_N^2 - x_0^2 - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     ```\n*\n* -   Rearranging terms gives us the update equation\n*\n*     ```tex\n*     \\begin{align*}\n*     (N-1)(\\Delta s^2) &= (x_N - x_0)(x_N + x_0) - (x_N - x_0)(\\bar{x}_{i+1} + \\bar{x}_{i})\n*     &= (x_N - x_0)(x_N + x_0 - \\bar{x}_{i+1} - \\bar{x}_{i}) \\\\\n*     &= (x_N - x_0)(x_N - \\bar{x}_{i+1} + x_0 - \\bar{x}_{i})\n*     \\end{align*}\n*     ```\n*\n* @param {Collection} [out] - output array\n* @param {PositiveInteger} window - window size\n* @throws {TypeError} output argument must be array-like\n* @throws {TypeError} window size must be a positive integer\n* @returns {Function} accumulator function\n*\n* @example\n* var accumulator = incrmmeanvar( 3 );\n*\n* var v = accumulator();\n* // returns null\n*\n* v = accumulator( 2.0 );\n* // returns [ 2.0, 0.0 ]\n*\n* v = accumulator( -5.0 );\n* // returns [ -1.5, 24.5 ]\n*\n* v = accumulator( 3.0 );\n* // returns [ 0.0, 19.0 ]\n*\n* v = accumulator( 5.0 );\n* // returns [ 1.0, 28.0 ]\n*\n* v = accumulator();\n* // returns [ 1.0, 28.0 ]\n*/\nfunction incrmmeanvar( out, window ) {\n\tvar meanvar;\n\tvar delta;\n\tvar buf;\n\tvar tmp;\n\tvar M2;\n\tvar mu;\n\tvar d1;\n\tvar d2;\n\tvar W;\n\tvar N;\n\tvar n;\n\tvar i;\n\tif ( arguments.length === 1 ) {\n\t\tmeanvar = [ 0.0, 0.0 ];\n\t\tW = out;\n\t} else {\n\t\tif ( !isArrayLike( out ) ) {\n\t\t\tthrow new TypeError( format( '1IZ9a', out ) );\n\t\t}\n\t\tmeanvar = out;\n\t\tW = window;\n\t}\n\tif ( !isPositiveInteger( W ) ) {\n\t\tthrow new TypeError( format( '1IZ9b', W ) );\n\t}\n\tbuf = new Float64Array( W );\n\tn = W - 1;\n\tM2 = 0.0;\n\tmu = 0.0;\n\ti = -1;\n\tN = 0;\n\n\treturn accumulator;\n\n\t/**\n\t* If provided a value, the accumulator function returns updated accumulated values. If not provided a value, the accumulator function returns the current accumulated values.\n\t*\n\t* @private\n\t* @param {number} [x] - input value\n\t* @returns {(ArrayLikeObject|null)} output array or null\n\t*/\n\tfunction accumulator( x ) {\n\t\tvar k;\n\t\tvar v;\n\t\tif ( arguments.length === 0 ) {\n\t\t\tif ( N === 0 ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tmeanvar[ 0 ] = mu;\n\t\t\tif ( N === 1 ) {\n\t\t\t\tif ( isnan( M2 ) ) {\n\t\t\t\t\tmeanvar[ 1 ] = NaN;\n\t\t\t\t} else {\n\t\t\t\t\tmeanvar[ 1 ] = 0.0;\n\t\t\t\t}\n\t\t\t} else if ( N < W ) {\n\t\t\t\tmeanvar[ 1 ] = M2 / (N-1);\n\t\t\t} else {\n\t\t\t\tmeanvar[ 1 ] = M2 / n;\n\t\t\t}\n\t\t\treturn meanvar;\n\t\t}\n\t\t// Update the index for managing the circular buffer:\n\t\ti = (i+1) % W;\n\n\t\t// Case: incoming value is NaN, the sliding second moment is automatically NaN...\n\t\tif ( isnan( x ) ) {\n\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\tmu = NaN;\n\t\t\tM2 = NaN;\n\t\t}\n\t\t// Case: initial window...\n\t\telse if ( N < W ) {\n\t\t\tbuf[ i ] = x; // update buffer\n\t\t\tN += 1;\n\t\t\tdelta = x - mu;\n\t\t\tmu += delta / N;\n\t\t\tM2 += delta * (x - mu);\n\n\t\t\tmeanvar[ 0 ] = mu;\n\t\t\tif ( N === 1 ) {\n\t\t\t\tmeanvar[ 1 ] = 0.0;\n\t\t\t} else {\n\t\t\t\tmeanvar[ 1 ] = M2 / (N-1);\n\t\t\t}\n\t\t\treturn meanvar;\n\t\t}\n\t\t// Case: N = W = 1\n\t\telse if ( N === 1 ) {\n\t\t\tmu = x;\n\t\t\tM2 = 0.0;\n\t\t\tmeanvar[ 0 ] = x;\n\t\t\tmeanvar[ 1 ] = 0.0;\n\t\t\treturn meanvar;\n\t\t}\n\t\t// Case: outgoing value is NaN, and, thus, we need to compute the accumulated values...\n\t\telse if ( isnan( buf[ i ] ) ) {\n\t\t\tN = 1;\n\t\t\tmu = x;\n\t\t\tM2 = 0.0;\n\t\t\tfor ( k = 0; k < W; k++ ) {\n\t\t\t\tif ( k !== i ) {\n\t\t\t\t\tv = buf[ k ];\n\t\t\t\t\tif ( isnan( v ) ) {\n\t\t\t\t\t\tN = W; // explicitly set to avoid `N < W` branch\n\t\t\t\t\t\tmu = NaN;\n\t\t\t\t\t\tM2 = NaN;\n\t\t\t\t\t\tbreak; // second moment is automatically NaN, so no need to continue\n\t\t\t\t\t}\n\t\t\t\t\tN += 1;\n\t\t\t\t\tdelta = v - mu;\n\t\t\t\t\tmu += delta / N;\n\t\t\t\t\tM2 += delta * (v - mu);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Case: neither the current second moment nor the incoming value are NaN, so we need to update the accumulated values...\n\t\telse if ( isnan( M2 ) === false ) {\n\t\t\ttmp = buf[ i ];\n\t\t\tdelta = x - tmp;\n\t\t\td1 = tmp - mu;\n\t\t\tmu += delta / W;\n\t\t\td2 = x - mu;\n\t\t\tM2 += delta * (d1 + d2);\n\t\t}\n\t\t// Case: the current second moment is NaN, so nothing to do until the buffer no longer contains NaN values...\n\t\tbuf[ i ] = x;\n\n\t\tmeanvar[ 0 ] = mu;\n\t\tmeanvar[ 1 ] = M2 / n;\n\t\treturn meanvar;\n\t}\n}\n\n\n// EXPORTS //\n\nexport default incrmmeanvar;\n"],"names":["incrmmeanvar","out","window","meanvar","delta","buf","tmp","M2","mu","W","N","n","i","arguments","length","isArrayLike","TypeError","format","isPositiveInteger","Float64Array","x","k","v","isnan","NaN"],"mappings":";;qfAgIA,SAASA,EAAcC,EAAKC,GAC3B,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EAGAC,EACAC,EACAC,EACAC,EACJ,GAA0B,IAArBC,UAAUC,OACdX,EAAU,CAAE,EAAK,GACjBM,EAAIR,MACE,CACN,IAAMc,EAAad,GAClB,MAAM,IAAIe,UAAWC,EAAQ,QAAShB,IAEvCE,EAAUF,EACVQ,EAAIP,CACJ,CACD,IAAMgB,EAAmBT,GACxB,MAAM,IAAIO,UAAWC,EAAQ,QAASR,IASvC,OAPAJ,EAAM,IAAIc,EAAcV,GACxBE,EAAIF,EAAI,EACRF,EAAK,EACLC,EAAK,EACLI,GAAK,EACLF,EAAI,EAWJ,SAAsBU,GACrB,IAAIC,EACAC,EACJ,GAA0B,IAArBT,UAAUC,OACd,OAAW,IAANJ,EACG,MAERP,EAAS,GAAMK,EACJ,IAANE,EACCa,EAAOhB,GACXJ,EAAS,GAAMqB,IAEfrB,EAAS,GAAM,EAGhBA,EAAS,GADEO,EAAID,EACAF,GAAMG,EAAE,GAERH,EAAKI,EAEdR,GAMR,GAHAS,GAAKA,EAAE,GAAKH,EAGPc,EAAOH,GACXV,EAAID,EACJD,EAAKgB,IACLjB,EAAKiB,QAGD,IAAKd,EAAID,EAab,OAZAJ,EAAKO,GAAMQ,EAIXb,IAFAH,EAAQgB,EAAIZ,IAEGY,GADfZ,GAAMJ,GAFNM,GAAK,KAKLP,EAAS,GAAMK,EAEdL,EAAS,GADC,IAANO,EACW,EAEAH,GAAMG,EAAE,GAEjBP,EAGH,GAAW,IAANO,EAKT,OAJAF,EAAKY,EACLb,EAAK,EACLJ,EAAS,GAAMiB,EACfjB,EAAS,GAAM,EACRA,EAGH,GAAKoB,EAAOlB,EAAKO,KAIrB,IAHAF,EAAI,EACJF,EAAKY,EACLb,EAAK,EACCc,EAAI,EAAGA,EAAIZ,EAAGY,IACnB,GAAKA,IAAMT,EAAI,CAEd,GADAU,EAAIjB,EAAKgB,GACJE,EAAOD,GAAM,CACjBZ,EAAID,EACJD,EAAKgB,IACLjB,EAAKiB,IACL,KACA,CAIDjB,IAFAH,EAAQkB,EAAId,IAEGc,GADfd,GAAMJ,GAFNM,GAAK,IAIL,OAIuB,IAAhBa,EAAOhB,KAChBD,EAAMD,EAAKO,GAKXL,IAJAH,EAAQgB,EAAId,IACPA,EAAME,GAENY,GADLZ,GAAMJ,EAAQK,KAGd,CAMD,OAJAJ,EAAKO,GAAMQ,EAEXjB,EAAS,GAAMK,EACfL,EAAS,GAAMI,EAAKI,EACbR,CACP,CACF"}